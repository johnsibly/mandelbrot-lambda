<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <!-- <script src='https://github.com/MikeMcl/big.js/blob/master/big.min.js'></script> -->
  <script src='../big.js/big.js'></script>
  <script type="application/javascript">
    "use strict";

    // const max_iteration = 4096;
    const max_iteration = 10;
    var scale = new Big(1.0);
    var centreX = new Big(-0.5);
    var centreY = new Big(0.0);
    var startx = new Big(-2.5); 
    var starty = new Big(-1.0); 

    function writeMessage(canvas, message) {
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, 200, 30);
        context.font = '10pt Calibri';
        context.fillStyle = 'black';
        context.fillText(message, 10, 25);
    }
    function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
    }
    
    function drawOnLoad() {
        var canvas = document.getElementById('canvas');
        canvas.width = 800;
        canvas.height = 400;
        //canvas.style.width = "800px";
        //canvas.style.height = "400px";
        var context = canvas.getContext('2d')
    //    context.scale(2,2)

        var elemLeft = canvas.offsetLeft,
            elemTop = canvas.offsetTop,
            elements = [];

        canvas.addEventListener('click', function(event) {
            console.log("click");

            var x = event.pageX - elemLeft,
                y = event.pageY - elemTop;

            console.log('before centerX=' + centreX + ', centreY=' + centreY + ', scale=' + scale);

            let virt = pixelsToVirtual(x, y, startx, starty);

            centreX = virt.vx;
            centreY = virt.vy;
            scale = scale.div(2.0);

            console.log('centerX=' + centreX + ', centreY=' + centreY + ', scale=' + scale);

            draw();
        }, false);
        
        canvas.addEventListener('mousemove', function(evt) {
            var mousePos = getMousePos(canvas, evt);
            let x = mousePos.x;
            let y = mousePos.y;
            
            let virt = pixelsToVirtual(x, y, startx, starty);

            var message = x + ',' + y + ' / ' + virt.vx.toFixed(2) + ',' + virt.vy.toFixed(2);
            writeMessage(canvas, message);
        }, false);

        // allow OnLoad to complete
        setTimeout(function(){ draw(); }, 10);
        
    }

    function draw() {
        let pixelWidth = scale.div(10); //scale.div(200);
        console.log('pixelWidth: ' + pixelWidth);

        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 800, 400);

            startx = centreX.minus(scale.times(2.0));
            let endx = centreX.plus(scale.times(2.0));
            starty = centreY.minus(scale);
            let endy = centreY.plus(scale);
            console.log(+startx + ' ' + +endx + ' ' + +starty + ' ' + +endy);

            let start = virtualToPixels(startx, starty, startx, starty);
            let end = virtualToPixels(endx, endy, startx, starty);
            console.log('pix bounds: ' + +start.mappedX + ' ' + +start.mappedY + ' ' + +end.mappedX + ' ' + +end.mappedY);

            let operations = 0;
            for (let xp = startx; xp.lt(endx); xp=xp.plus(pixelWidth)) {
                console.log(+xp);
                for (let yp = starty; yp.lt(endy); yp=yp.plus(pixelWidth)) {
                    let x = new Big(0.0);
                    let y = new Big(0.0);
                    let iteration = 0;
                    const big4 = new Big(4.0);
                    while ((x.pow(2).plus(y.pow(2))).lt(big4) && iteration < max_iteration) {
                        let xtemp = x.pow(2).minus(y.pow(2)).plus(xp);
                        y = x.times(y).times(2.0).plus(yp);
                        x = xtemp;
                        iteration++;
                        operations++;
                    }
                    
                    let color = getColour(iteration);
                    let mapped = virtualToPixels(xp, yp, startx, starty);
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(mapped.mappedX, mapped.mappedY, 1, 1); 
                } 
            } 
            console.log('opertaions: ' + operations);
        }
    }

    function setPixel(imageData, x, y, r, g, b, a) {
        index = (x + y * imageData.width) * 4;
        imageData.data[index+0] = r;
        imageData.data[index+1] = g;
        imageData.data[index+2] = b;
        imageData.data[index+3] = a;
    }

    function pixelsToVirtual(x, y, startx, starty){
        let bigx = new Big(x);
        let bigy = new Big(y);
        let vx = bigx.times(scale).div(200.0).plus(new Big(startx));
        let vy = bigy.times(scale).div(200.0).plus(new Big(starty));
        return {vx, vy};
    }

    function virtualToPixels(x, y, startx, starty){
        let Big200 = new Big(200.0);

        let mappedX = Big200.div(scale).times(x.minus(startx))    
        let mappedY = Big200.div(scale).times(y.minus(starty))    
        return {mappedX, mappedY};
    }

    function getColour(iterations){
        let r=0, g=0, b=0;
        if (iterations == max_iteration) {
            // (R,G,B) = (0, 0, 0);  /* In the set. Assign black. */
        } else if (iterations < 64) {
            r = iterations * 2; //, 0, 0);    /* 0x0000 to 0x007E */
        } else if (iterations < 128) {
            r = (((iterations - 64) * 128) / 126) + 128; //, 0, 0);    /* 0x0080 to 0x00C0 */
        } else if (iterations < 256) {
            r= (((iterations - 128) * 62) / 127) + 193; //, 0, 0);    /* 0x00C1 to 0x00FF */
        } else if (iterations < 512) {
            r = 255; 
            g = (((iterations - 256) * 62) / 255) + 1; //, 0);    /* 0x01FF to 0x3FFF */
        } else if (iterations < 1024) {
            r = 255; 
            g = (((iterations - 512) * 63) / 511) + 64; //, 0);   /* 0x40FF to 0x7FFF */
        } else if (iterations < 2048) {
            r = 255; 
            g = (((iterations - 1024) * 63) / 1023) + 128; //, 0);   /* 0x80FF to 0xBFFF */
        } else if (iterations < 4096) {
            r = 255; 
            g = (((iterations - 2048) * 63) / 2047) + 192; //, 0);   /* 0xC0FF to 0xFFFF */
        } else {
            r = 255; 
            g = 255;
            // (R, G, b) = (255, 255, 0);
        }
        return ["rgb(",r,",",g,",",b,")"].join("");
    }

  </script>
 </head>
 <body onload="drawOnLoad();">
   <canvas id="canvas" width="800" height="400"></canvas>
 </body>
</html>
