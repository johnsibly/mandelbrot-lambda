<!DOCTYPE html>
<html>
 <head>
  <meta charset="utf-8"/>
  <script type="application/javascript">
    "use strict";
    const max_iteration = 1000;
    var scale = 1.0;
    var centreX = -0.5;
    var centreY = 0.0;
    var startx = -2.5; 
    var starty = -1.0; 

    function writeMessage(canvas, message) {
        var context = canvas.getContext('2d');
        context.clearRect(0, 0, 200, 30);
        context.font = '10pt Calibri';
        context.fillStyle = 'black';
        context.fillText(message, 10, 25);
    }
    function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
    }
    
    function drawOnLoad() {
        var canvas = document.getElementById('canvas');
        var elemLeft = canvas.offsetLeft,
            elemTop = canvas.offsetTop,
            context = canvas.getContext('2d'),
            elements = [];

        canvas.addEventListener('click', function(event) {
            console.log("click");

            var x = event.pageX - elemLeft,
                y = event.pageY - elemTop;

            console.log('before centerX=' + centreX + ', centreY=' + centreY + ', scale=' + scale);

            let virt = pixelsToVirtual(x, y, startx, starty);

            centreX = virt.vx;
            centreY = virt.vy;
            scale = scale/2;

            console.log('centerX=' + centreX + ', centreY=' + centreY + ', scale=' + scale);

            draw();
        }, false);
        
        canvas.addEventListener('mousemove', function(evt) {
            var mousePos = getMousePos(canvas, evt);
            let x = mousePos.x;
            let y = mousePos.y;
            
            let virt = pixelsToVirtual(x, y, startx, starty);

            var message = x + ',' + y + ' / ' + virt.vx.toFixed(2) + ',' + virt.vy.toFixed(2);
            writeMessage(canvas, message);
        }, false);

        draw();
    }

    function draw() {
        let pixelWidth = scale / 200;
        console.log('pixelWidth: ' + pixelWidth);

        if (canvas.getContext) {
            var ctx = canvas.getContext('2d');
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 800, 400);

            startx = centreX-(2*scale);
            let endx = (centreX+(2*scale));
            starty = (centreY-scale);
            let endy = (centreY+scale);
            console.log(startx + ' ' + endx + ' ' + starty + ' ' + endy);

            let start = virtualToPixels(startx, starty, startx, starty);
            let end = virtualToPixels(endx, endy, startx, starty);
            console.log('pix bounds: ' + start.mappedX + ' ' + start.mappedY + ' ' + end.mappedX + ' ' + end.mappedY);

            let operations = 0;
            for (let xp = startx; xp<endx; xp=xp+pixelWidth) {
                for (let yp = starty; yp<endy; yp=yp+pixelWidth) {
                    let x = 0.0;
                    let y = 0.0;
                    let iteration = 0;
                    
                    while ((x*x + y*y) < 4 && iteration < max_iteration) {
                        let xtemp = x*x - y*y + xp;
                        y = 2*x*y + yp;
                        x = xtemp;
                        iteration++;
                        operations++;
                    }
                    let color = getColour(iteration);
                    let mapped = virtualToPixels(xp, yp, startx, starty);
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(mapped.mappedX, mapped.mappedY, mapped.mappedX+1, mapped.mappedY+1); 
                } 
            } 
            console.log('opertaions: ' + operations);
        }
    }

    function pixelsToVirtual(x, y, startx, starty){
        let vx = (x * scale / 200.0) + startx;
        let vy = (y * scale / 200.0) + starty;
        return {vx, vy};
    }

    function virtualToPixels(x, y, startx, starty){
        let mappedX = (200.0/scale)*(x-startx);
        let mappedY = (200.0/scale)*(y-starty);
        return {mappedX, mappedY};
    }

    function getColour(iterations){
        let r=0, g=0, b=0;
        if (iterations == max_iteration) {
            // (R,G,B) = (0, 0, 0);  /* In the set. Assign black. */
        } else if (iterations < 64) {
            r = iterations * 2; //, 0, 0);    /* 0x0000 to 0x007E */
        } else if (iterations < 128) {
            r = (((iterations - 64) * 128) / 126) + 128; //, 0, 0);    /* 0x0080 to 0x00C0 */
        } else if (iterations < 256) {
            r= (((iterations - 128) * 62) / 127) + 193; //, 0, 0);    /* 0x00C1 to 0x00FF */
        } else if (iterations < 512) {
            r = 255; 
            g = (((iterations - 256) * 62) / 255) + 1; //, 0);    /* 0x01FF to 0x3FFF */
        } else if (iterations < 1024) {
            r = 255; 
            g = (((iterations - 512) * 63) / 511) + 64; //, 0);   /* 0x40FF to 0x7FFF */
        } else if (iterations < 2048) {
            r = 255; 
            g = (((iterations - 1024) * 63) / 1023) + 128; //, 0);   /* 0x80FF to 0xBFFF */
        } else if (iterations < 4096) {
            r = 255; 
            g = (((iterations - 2048) * 63) / 2047) + 192; //, 0);   /* 0xC0FF to 0xFFFF */
        } else {
            r = 255; 
            g = 255;
            // (R, G, b) = (255, 255, 0);
        }
        return ["rgb(",r,",",g,",",b,")"].join("");
    }

  </script>
 </head>
 <body onload="drawOnLoad();">
   <canvas id="canvas" width="800" height="400"></canvas>
 </body>
</html>
